# javaScript 排序算法

1. 插入排序
- 工作原理
    通过构建有序序列，从后向前扫描已排序的序列，将未排序的数据插入所找的位置。在实现上，采用in-place排序(只需要使用O(1)的额外空间排序)
- 思想与实现
    (1) 从第一个元素开始，第一个元素默认已经被排序
    (2) 取出下一个元素，从排好序的元素序列后面向前扫描
    (3) 比较所扫描到的元素与新元素的大小，若大于新元素，则将所扫描到的元素向后移一位
    (4) 循环重复步骤(3)，直到找到已排序的元素小于或等于新元素
    (5) 将新元素插入到找到元素的后面
    (6) 重复执行步骤(2) ~ 步骤(5)
- 算法分析
    (1) 最佳情况  输入数组按升序排列  T(n) = O(n)
    (2) 最坏情况  输入数组按降序排列  T(n) = O(n^2)
    (3) 平均情况  T(n) = O(n^2)
    (4) 稳定性    稳定
    (5) 空间复杂度 O(1)

2. 冒泡排序 (越小的元素会经由交换慢慢"浮"到数列的顶端) 以从左往右、从小到大为例
- 算法原理(从左到右比较元素，进行单向的位置交换)
    (1) 从左到右，依次比较相邻元素的大小，更大的元素交换到右边
    (2) 从第一组相邻元素比较到最后一组相邻元素，结束后最后一个元素则是参与比较的元素中的最大的元素
    (3) 再重新从左到右依次比较相邻元素，但前一轮中得到的最后一个元素不参与比较，由此得到新一轮的最大元素
    (4) 按照上述步骤，直到没有任何一组元素需要进行比较
- 实现
    (1) 暴力
        使用双重循环进行排序，外部循环控制所有回合，内部循环代表每一轮冒泡处理的，先进行相邻元素比较，再进行元素的交换
    (2) 改进版
        一般情况下，数列的有序区的长度与排序的轮数相等
        在一轮排序中，以数组总长度减去有序区长度为新一轮排序的长度进行比较与交换
    (3) 进一步改进版
        在外部循环设置一个标志flag，初始值为true，若内部循环进行了交换，则把标记设置为false，如果一轮结束后标记为flag，意味着数组已排好了序，则跳出循环，以此减少数组有序后不必要的排序次数
    (4) 晋级改进版
        若数列的有序区长度大于排序的轮数时，记录每一轮的排序最后的位置，其就是无序数列与有序数列的边界
    (5) 升级版 (鸡尾酒排序，也称快乐小时排序或双向冒泡排序)
        - 鸡尾酒排序的元素比较和交换过程是双向的
        - 原理
            (一) 先对数组进行从左到右的冒泡排序，则最大元素去到数组最右端
            (二) 再对数组进行从右向左的冒泡排序，则最小的元素去到数组最左端
            (三) 以此类推，依次改变冒泡的方向，进行步骤(一)和步骤(二)
        - 时间复杂度与空间复杂度跟冒泡排序相接近
        - 优点：在某些特定情况下，其相对于冒泡排序可以减少大量的比较轮数
        - 缺点：代码量几乎扩大一倍
        - 适用于大部分元素已经有序的情况下
- 算法分析
    (1) 最佳情况  输入数组按升序排列  T(n) = O(n)
    (2) 最坏情况  输入数组按降序排列  T(n) = O(n^2)
    (3) 平均情况  T(n) = O(n^2)
    (4) 稳定性    稳定
    (5) 空间复杂度 O(1)