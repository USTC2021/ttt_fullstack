## 链表

- 缓存 提高数据读取性能的技术 利用空间换时间的设计思想
  - 若将数据存储在硬盘上，会比较节省内存，但每次查找数据都要访问一次硬盘就会比较慢，但若通过缓存技术，事先将数据加载在内存中，虽然会比较消耗内存空间，但每次查询数据的速度却会大大提升。
  - 对于执行慢的程序可以通过消耗更多的内存来优化(以空间换时间)，但对于消耗内存过多的程序，可以通过消耗更多时间来降低内存的消耗(以时间换空间)

- 常用的缓存淘汰策略
  1. 先进先出策略FIFO
  2. 最少使用策略LFU
  3. 最近最少使用策略LRU

- 链表的概念
  链表：通过指针将一组零散的内存块串联在一起
  内存块：链表的结点
  结点：存储数据、后继指针（记录链上的下一个结点的地址）
  头结点：第一个结点 记录链表的基地址
  尾结点：最后一个结点 指针指向一个空地址Null
  哨兵结点：不存储数据的
  带头链表：有哨兵结点的链表
  不带头链表：没有哨兵结点的链表

- 常见的链表结构
  1. 单链表
    - 链表的插入和删除
      只需要考虑相邻结点指针的改变，时间复杂度为O(1)
    - 链表随机访问第K个元素
      根据指针一个结点一个结点地依次遍历，直到找到对应的结点，时间复杂度O(n)

  2. 循环链表
    - 特殊的单链表
    - 与单链表唯一的区别是尾结点指针指向的是链表的头结点
    - 优点是从链尾到链头比较方便
    - 当要处理的数据具有环型结构特点时，适合采用循环链表
  
  3. 双向链表
    - 每个结点有一个前驱指针prev指向前面的结点，也有一个后继指针next指向后面的结点
    - 双向链表要比单链表占用更多的内存空间
      双向链表需要额外的两个空间来存储后继结点和前驱结点的地址
    - 特点：从结构上看，双向链表可以支持O(1)时间复杂度的情况下找到前驱结点
    - 在某些情况下，双向链表的插入、删除等操作要比单链表简单、高效，如删除给定指针指向的结点、在链表的某个指定结点前面插入一个结点

  4. 双向循环链表

- 链表的缺点
  若代码对内存的使用非常苛刻，那么更适合使用数组。因为链表中的每个结点都需要消耗额外的存储空间去存储一份指向下一个结点的指针，所以内存消耗会翻倍，而且，对链表进行频繁的插入、删除操作会导致频繁的内存申请和释放，容易造成内存碎片

- 实现基于链表的LRU缓存淘汰算法
  我们维护一个有序单链表，越靠近链表尾部的结点是越早之前访问的。当有一个新的数据被访问时，我们从链表头部开始顺序遍历链表
  1. 若此数据之前已经被缓存在链表中，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部
  2. 若此数据没有在缓存链表中
    - 若此时缓存未满，则将此结点直接插入到链表的头部
    - 若此时缓存已满，则将链表尾部结点删除，然后将新的数据结点插入链表的头部

- 指针 
  将某个变量赋值给指针，即将这个变量的地址赋值给指针
  指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量
  p -> next = p -> next -> next  p结点的next指针存储了p结点的下下一个结点的内存地址

- 链表中，警惕指针丢失和内存泄漏

- 删除链表结点时，一定要记得手动释放内存空间

- 针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理

- 检查链表代码是否正确的边界条件
  1. 若链表为空，代码是否能正常工作
  2. 若链表只包含一个结点，代码是否能正常工作
  3. 若链表只包含两个结点，代码是否能正常工作
  4. 代码逻辑在处理头结点和尾结点的时候，是否能正常工作

- 链表常见的几个操作
  1. 单链表反转
  2. 链表中环的检测
  3. 两个有序链表的合并
  4. 删除链表倒数第n个结点
  5. 求链表的中间结点